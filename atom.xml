<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dream1ce.github.io</id>
    <title>Learning Bolg</title>
    <updated>2020-04-15T14:32:50.794Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dream1ce.github.io"/>
    <link rel="self" href="https://dream1ce.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dream1ce.github.io/images/avatar.png</logo>
    <icon>https://dream1ce.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Learning Bolg</rights>
    <entry>
        <title type="html"><![CDATA[Ray Tracing:Whitted-Style]]></title>
        <id>https://dream1ce.github.io/post/ray-tracingwhitted-style/</id>
        <link href="https://dream1ce.github.io/post/ray-tracingwhitted-style/">
        </link>
        <updated>2020-04-15T12:31:04.000Z</updated>
        <summary type="html"><![CDATA[<p>未完待续</p>
]]></summary>
        <content type="html"><![CDATA[<p>未完待续</p>
<!-- more -->
<p>在了解光线追踪之前，先要明白光栅化的阴影是怎么做的，有什么缺陷。</p>
<h1 id="shadow-mapping光栅化的阴影">Shadow Mapping（光栅化的阴影）</h1>
<p><strong>主要思想：</strong> 所谓阴影就是你看的到但是光看不到的部分。<br>
<strong>处理步骤：</strong> 根据主要思想那么很容易的出如何产生阴影，就是先将camera防止在光源出进行一次观测，记录场景的深度，之后再把camera放在实际视角位置进行观测，最后在进行光栅化的时候查询对应像素的深度看是否被物体遮挡，没被遮挡的就正常显示，否则为阴影。<br>
<strong>缺陷：</strong></p>
<ol>
<li>阴影质量取决于Shadow Mapping 的采样点个数如果采样点太少那么就会在阴影产生锯齿，采样点过多就需要大量的计算。</li>
<li>Shadow Mapping 只能用于单个点光源。（PS： 有一些处理的方法可以用于多个点光源，但是计算量会大幅增加，直到不可控）。</li>
<li>阴影边缘明显无法生成软阴影，根据思想易得，而显示中大部分是软阴影。<br>
由以上的缺点我们直到，最好让光线决定我们能看到什么而不是设计一种简化模型来计算物体表面是什么颜色。<br>
#Whitted-Style Ray Tracing<br>
首先我们要明白光线追踪，光线有什么性质。<br>
###光线的性质</li>
<li>沿直线传播</li>
<li>光线与光线之间不会发生碰撞。（这条仅限与一些简单的模型，复杂模型中还会考虑光的波动性）</li>
<li>如果有一条光线能从光源到眼睛，那么也能找到一条射线从眼睛到光源，且这两条路线相等。</li>
</ol>
<h3 id="光追思想">光追思想</h3>
<p>由以上的光的性质那么思想就很容易确定下来，从Camera出发每个像素点发射一条射线，由射线打到的面上的某点计算光源对于这个点应该反应的是什么颜色，同时射线还会反射，这点也要计算。那么问题就被分解为求光线和表面的交点，求出焦点像素的颜色。最后显示的颜色即可。<br>
颜色其实无所谓由Texture来决定颜色，实际上的问题是求光线和表面的交点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Geometry: Mesh Operation]]></title>
        <id>https://dream1ce.github.io/post/geometry-mesh-operation/</id>
        <link href="https://dream1ce.github.io/post/geometry-mesh-operation/">
        </link>
        <updated>2020-04-13T14:05:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mesh-subdivision曲面细分">Mesh Subdivision（曲面细分）</h1>
<h3 id="loop-subdivisionloop细分">Loop Subdivision（Loop细分）</h3>
<p>Loop subdivision 是针对三角形面片而做的一种细分方法。<br>
<strong>第一步</strong> 把每条边的中点作为一个新的点。新的点在一条边上，一条边必定被两个三角形共享，在此定义被两个三角形共享的两个点为近点，剩余两个为远点。<br>
<strong>第二步</strong> 依照一定的规则更新新的点和旧的点相应坐标。<br>
<strong>更新规则如下</strong> 新点 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>远点之和+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>3</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>近点之和        旧点 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mi>n</mi><mo>∗</mo><mi>u</mi><mo>)</mo><mi mathvariant="normal">自</mi><mi mathvariant="normal">己</mi><mo>+</mo><mi>u</mi><mo>∗</mo><mo>(</mo><mi mathvariant="normal">相</mi><mi mathvariant="normal">邻</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">和</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(1-n*u)自己+u*(相邻点之和)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">己</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">邻</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">和</span><span class="mclose">)</span></span></span></span></p>
<h3 id="catmall-clark-subdivision">Catmall-Clark Subdivision</h3>
<p>Catmall-Clark Subdivision 是针对一般平面更加通用的方法。（PS:Catmall是2020的图灵奖得主）<br>
<strong>新增点：</strong> Face point(原来多边形的中点)、Edge point（边中点）、New Vertex point(旧点调整之后的新顶点)<br>
<strong>计算公式：</strong></p>
<ol>
<li>Face point： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>F</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_F=\frac{1}{n}\sum_{i=1}^NV_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326231em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为之前面上的顶点</li>
<li>Edge point： 取最近的四个顶点包括面顶点求和</li>
<li>New Vertex point：取相邻边的中点坐标求平均<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">*\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord">∗</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>加上相邻的面的中点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mfrac><mn>2</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">*\frac{2}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord">∗</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>加上自己<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>3</mn></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">*\frac{n-3}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord">∗</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
<strong>性质：</strong> 不断迭代做曲面细分操作之后，奇异点（degree<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\not ={4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span></span></span></span></span>）会是一个常数。</li>
</ol>
<h1 id="mesh-simplification曲面简化">Mesh Simplification(曲面简化)</h1>
<h3 id="edge-collapse边缘坍缩">Edge Collapse（边缘坍缩）</h3>
<p>原理就是让新点，离原先面的距离的平方最小，这里引入Quadric Error Metrics ,是一个最优化问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Geometry：Curve & Surface]]></title>
        <id>https://dream1ce.github.io/post/geometry/</id>
        <link href="https://dream1ce.github.io/post/geometry/">
        </link>
        <updated>2020-04-09T14:18:03.000Z</updated>
        <content type="html"><![CDATA[<p>在物体几何的表示中，一共有两种表示方法：隐式表示法和显式表示法。</p>
<h1 id="隐式表示法">隐式表示法</h1>
<ol>
<li>用数学公式表示如：圆的数学公式、球的数学公式....</li>
<li>CSG(Constractive Solid Geometry) 思想就是用最基本的图形去表示复杂图形，常用Boolean运算来表示图形。</li>
<li>Distance Function(距离公式) 也是基本图形组合，但是利用距离向量场可以得到更加圆滑的组合，算是一种扩充，但是不代表可以取代CSG。</li>
<li>分形 数学上用的多一些比如雪花、松树之类的。</li>
</ol>
<h1 id="显式表示">显式表示</h1>
<ol>
<li><strong>点云</strong> ：将模型用很多密集的点表示。不常用</li>
<li><strong>多边形面</strong>：常用会形成obj文件，3DMax、Maya等建模软件常用。</li>
<li><strong>Bezier Curve</strong> ： 使用几个控制点来表示一条曲线，简单理解：点在t变化的同时处于不同的位置，关于参数t的一个表达式。贝塞尔曲线恒一些特别的性质1.其一定经过控制点的起点和终点。2、仿射不变性：其在做仿射变换的时候，直接将线做仿射等于先将控制点做仿射变换在由变换后的点划线。3、凸包性质，贝塞尔曲线已知在以控制点形成的凸包中。</li>
<li><strong>Piecewise Bezier Curve</strong> : 逐段的贝塞尔曲线，为什么会有逐段的贝塞尔曲线呢？因为贝塞尔曲线不存在局部调整的性质，每当调整一个控制点就要对整个曲线进行调整，所以逐段的贝塞尔曲线因此而生，当然除了逐段的贝塞尔还有B-Splines等方法可以解决这个问题。</li>
<li><strong>Bezier Surfaces</strong>： 理解简单就是贝塞尔曲线上的点沿着垂直方向按照另一个贝塞尔曲线扫过就形成了贝塞尔曲面。有点像双线性插值。</li>
</ol>
<h1 id="mesh-operation-geometry-processing网格上的操作">Mesh Operation： Geometry Processing（网格上的操作）</h1>
<ol>
<li><strong>网格细分</strong> ：由一个多边形形成更多的多边形，来让细节更丰富。</li>
<li><strong>网格简化</strong> ：和上面的网格细分相反，是为了追求更高的性能将多变形数量减少。</li>
<li><strong>网格正规化</strong> ：让网格的每个三角形都趋于正三角形。会有很多好的性质。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shading:lecture 3(Texture Mapping)]]></title>
        <id>https://dream1ce.github.io/post/shadinglecture-3texture-mapping/</id>
        <link href="https://dream1ce.github.io/post/shadinglecture-3texture-mapping/">
        </link>
        <updated>2020-04-08T02:40:48.000Z</updated>
        <content type="html"><![CDATA[<p>材质映射是一种把高频信息、表面材质或颜色信息定义在图像或者模型上的一种方法。<br>
以下从小到大开始讲解 ：</p>
<h1 id="材质空间和模型">材质空间和模型</h1>
<p>在学习材质映射之前，先要明白材质映射和模型的关系。<br>
模型明显是三维的，其反应的是某个点或物体的空间信息，但是对于材质而言就相当与空间物体的一层表皮，所以二维的空间足以。<br>
材质常用的空间为：uv图，其记录的是材质贴图本身以及特定材质点对应的空间中的坐标信息。（PS:并非是每个点的信息）</p>
<h1 id="三角形内的材质映射">三角形内的材质映射</h1>
<p>由材质空间，我们假设已知三角形三个顶点的材质坐标，那么如何对三角形中的各个点进行材质的映射呢？</p>
<h4 id="重心坐标barycentic-coordinate">重心坐标(Barycentic Coordinate)</h4>
<p>为了让空间中的三角形和材质空间中的三角形的各个点能形成一一对应的关系，这里引入一个重心坐标的概念。设点<strong>D</strong> 为我们要求的点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(\alpha,\beta,\gamma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span></span> 为重心坐标，<strong>A</strong> 、<strong>B</strong> 、<strong>C</strong> 为我们已知的点，则要满足以下三个式子：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mi>A</mi><mo>+</mo><mi>β</mi><mi>B</mi><mo>+</mo><mi>γ</mi><mi>C</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\alpha A +\beta B + \gamma C =D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi><mo>+</mo><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha + \beta + \gamma = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mi>β</mi><mi>γ</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">非</mi><mi mathvariant="normal">负</mi></mrow><annotation encoding="application/x-tex">\alpha \beta \gamma 均为非负</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">负</span></span></span></span><br>
如果已求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mi>β</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha \beta \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>，那么对应的映射也就十分简单了（把材质空间的三个点的uv代进去即可）</li>
</ol>
<h6 id="如何求出重心坐标">如何求出重心坐标</h6>
<p>三角形对应分割面积之比即为重心坐标。（PS:网上可查）</p>
<h1 id="映射产生的问题">映射产生的问题</h1>
<p>在映射的过程中会产生一些问题比如材质过大或者材质过小的问题。</p>
<h3 id="问题材质过小-解决材质放大">问题：材质过小 解决：材质放大</h3>
<h5 id="就近nearst">就近（Nearst）</h5>
<p>这个就直接把离得最近的一个点的颜色拿来做填充就好了。（最简单）</p>
<h5 id="双线性插值biliner-interpolation">双线性插值（Biliner interpolation）</h5>
<p>这个插值就是在两个方向上对最近的点的颜色做一个加权平均。（权值可以自定）</p>
<h5 id="双三次线性插值bicubic-interpolation">双三次线性插值（Bicubic interpolation）</h5>
<p>这个思想和双线性插值有点类似但是他用了十六个相邻像素，四个一组，三次方程来进行插值。（计算量最大但是效果也最好，常常用在图片的放大和缩小）</p>
<h3 id="问题材质过大-解决材质缩小">问题：材质过大 解决：材质缩小</h3>
<h5 id="直接放弃法">直接放弃法</h5>
<p>将被缩去的像素直接丢弃，但是会出现问题，之间说了MSAA可以抗锯齿，这个就有点像MSAA的逆过程，但是会产生锯齿，影响画面效果</p>
<h5 id="放弃采样法">放弃采样法</h5>
<p>如果直接采样会产生锯齿，那么最简单的一个思路就是我不对特定点进行采样了，如果能直接知道附近颜色平均值那我就不用采样了，取平均即可</p>
<h5 id="mipmap">Mipmap</h5>
<p>如何求一个范围的平均值？将图像不断缩小（将图像模糊，四个像素混成一种颜色），每次缩小四倍，共产生<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>lg</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\lg_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 幅缩略图，可直接用来做范围查找(range query)，所需内存是原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>3</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>根据像素的大小直接查询最接近的Mipmap。缺点：对于非正方形的图形效果不是很好。<br>
<img src="https://dream1ce.github.io/post-images/1586318373356.jpg" alt="" loading="lazy"></p>
<h5 id="各向异性过滤anisotropic-filtering">各向异性过滤(Anisotropic Filtering)</h5>
<p>思想和Mipmap类似但是除了同时将宽和高缩小之外，还各进行了高和宽独自的缩小。<br>
<img src="https://dream1ce.github.io/post-images/1586318290370.png" alt="" loading="lazy"></p>
<h5 id="ewa-filtering">EWA Filtering</h5>
<p>这个更加复杂是用圆形来覆盖原来不规则的形状。</p>
<h1 id="在做shading时的其他技术">在做Shading时的其他技术</h1>
<p>####Enviroment Map(环境贴图)<br>
环境贴图主要是用来解决同一个物体，有一部分的光被自己挡住了，一般在比较写实的风格中会用到。Environment Map 记录了纹理上的相对高度，可以用来计算光是否被其一部分挡住了。<br>
####Bump Map(法线贴图)<br>
法线贴图是用来在不增加三角形的前提下，来使整个图形看上去有更多的纹理，但是有一个缺点就是在图形 的边缘位置会露陷，毕竟产生的不是真的凹凸形状。</p>
<h4 id="displacement-map">Displacement Map</h4>
<p>和法线贴图类似但是其是真的将形状发生了改变，用了曲面细分的相关技术。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shading:lecture 2(Pipeline)]]></title>
        <id>https://dream1ce.github.io/post/shadinglecture2pipeline/</id>
        <link href="https://dream1ce.github.io/post/shadinglecture2pipeline/">
        </link>
        <updated>2020-04-05T12:29:37.000Z</updated>
        <content type="html"><![CDATA[<p>以下的内容和硬件有些许关系。</p>
<h1 id="rendering-pipeline渲染管线">Rendering Pipeline(渲染管线)</h1>
<p>渲染管线又称渲染流水线，顾名思义其是用来表示从三维模型映射到二维图像直到呈现在屏幕上的整个过程。<br>
其大致的流程为：<strong>顶点数据-&gt;顶点着色器-&gt;曲面细分-&gt;几何着色器-&gt;图元组装-&gt;光栅化-&gt;片段着色器-&gt;测试混合阶段</strong></p>
<h4 id="顶点数据">顶点数据：</h4>
<p>顶点数据用来为后面的其他阶段提供顶点信息，用于后期的绘制。<br>
要注意的是在顶点数据阶段要向相应的图形图像接口表明是什么图元：常见的图元为点、线、三角面</p>
<h4 id="顶点着色器">顶点着色器：</h4>
<p>顶点着色器最主要进行坐标变换，从局部坐标到世界坐标、观测坐标、剪裁坐标的变换。在一些渲染方式中也会用来计算顶点的光照信息，如Groudaud Shading模型，但是效果不佳不常用。</p>
<h4 id="曲面细分">曲面细分：</h4>
<p>用镶嵌化技术对三角面进行细分，来增加三角面的个数。</p>
<h4 id="图元组装">图元组装：</h4>
<p>将输入的顶点信息组装成图元。</p>
<h4 id="光栅化">光栅化：</h4>
<p>将图形由连续转化为离散的像素点的过程。</p>
<h4 id="片段着色器">片段着色器：</h4>
<p>用来计算光照等其他可计算因素，来呈现屏幕上像素点最后的颜色。<br>
##注意：<br>
渲染管线的流程在不同的教科书中有不同的流程，以上划分仅仅为其中一个版本。</p>
<h1 id="shader着色器">Shader（着色器）</h1>
<p>Shader 中文名称为着色器，通俗的来讲就是负责绘制图像的内容的一种GPU程序。<br>
对于图形学来讲常用的Shader为Vertex Shader 和 Fragment Shader。<br>
以下列出其他Shader类型权当扩展：</p>
<ol>
<li>Geometry Shader：用来对于几何图形进行计算。</li>
<li>Compute Shader：一种通用的计算单元，能计算一些更复杂的逻辑。<br>
#显卡中的相应硬件：<br>
显卡中有大量的运算单元，用来专门执行相应类型的Shader，其处理器的类型均为SIMD（并不严谨），能在同时做大量并行的计算。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shading:lecture 1(Illumination)]]></title>
        <id>https://dream1ce.github.io/post/shading-lecture-1illumination/</id>
        <link href="https://dream1ce.github.io/post/shading-lecture-1illumination/">
        </link>
        <updated>2020-04-03T11:09:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shading着色">Shading（着色）</h1>
<p>Shading 表示对相应模型或者图像内容的绘制。在计算机图形学中表示相应的模型在映射到屏幕之后其像素点的有关对应值。其处理的内容包括但不限于对模型表面光的角度的计算、与光的距离、与观测点的距离、表面的材质相关的属性.etc</p>
<h1 id="illumination光照">Illumination(光照)</h1>
<p>PS:这里所说的光照仅表示了物体因为光照而对自身不同部分产生的明暗变化，并不包含物体所产生的阴影）</p>
<h4 id="diffuse漫反射">Diffuse(漫反射)</h4>
<p>在说明漫反射之前先要明白，影响物体漫反射强度的因素大概有这三点：<br>
1、物体表面材质对于光线的吸收程度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
2、光线照射到这点的角度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">角</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">弦</mi></mrow></mrow><annotation encoding="application/x-tex">\max{0,角度的余弦}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">角</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">弦</span></span></span></span></span> （PS:因为光的强度并不为负数所以最小也要取0）<br>
<strong>角度的余弦：</strong> 角度余弦的计算公式为平面法向量点乘光线的方向向量得到的向量归一化后为角度余 弦。<br>
3、光线到照射点时的强度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>I</mi><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{I}{r^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
以下对第三点进行解释，对于点光源而言可以将其的能量看作是均匀散布在一个球壳上的且其散布的能量总数是维持不变。所以到某一点的光强度其大小是和到点光源的距离的平方成反比的。<br>
由此可以推出漫反射相应像素点的光照强度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><msub><mi>K</mi><mi>i</mi></msub><mi>max</mi><mo>⁡</mo><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">余</mi><mi mathvariant="normal">弦</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">角</mi><mi mathvariant="normal">度</mi><mo>)</mo></mrow><mfrac><mi>I</mi><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">L_{i}=K_{i}\max{(0,余弦的角度)}\frac{I}{r^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">弦</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">角</span><span class="mord cjk_fallback">度</span><span class="mclose">)</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h4 id="mirror-reflection镜面反射">Mirror reflection(镜面反射)</h4>
<p>镜面反射与上文提到的漫反射相似，其反射强度的影响因素也有三点：<br>
1、物体表面材质对于光线的吸收程度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
2、光线的<strong>反射路径和视角方向的接近程度</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mn>0</mn><mo separator="true">,</mo><mi>h</mi><mo>∗</mo><mi>n</mi></mrow></mrow><annotation encoding="application/x-tex">\max{0,h*n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span></span> （PS:因为光的强度并不为负数所以最小也要取0）<br>
<strong>h(半程向量)：</strong> 半程向量是光线入射方向和视角方向的角平分方向。<br>
<strong>n(平面法向量):</strong> n为平面法向量<br>
3、光线到照射点时的强度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>I</mi><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{I}{r^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h4 id="amibent环境光">Amibent(环境光)</h4>
<p>环境光从四面八方折射而来，在本次教学的模型中简单的用一个常系数乘以光照强度来表示环境光。</p>
<h1 id="注意事项">注意事项</h1>
<p>以上所有的光照效果参考的均为Bling-Phong 反射模型，对于其他的模型可能有其他的计算方法，具体在什么时候用什么模型要参考具体情况来编制shader。</p>
<h1 id="rendering光照的渲染方式">Rendering(光照的渲染方式)</h1>
<p>光照一共有三种渲染的方式在此只是做简单的介绍：</p>
<ol>
<li>Flat Shading(平面渲染)：在平面取某个特定点用此点来表示整个面的渲染效果。（在面不是很多的时候效果不佳，在片面很多时效果向Phong Shading 趋近）</li>
<li>Gouraud Shading（顶点渲染）：将顶点的光照计算出来，并在平面内对像素进行插值操作。（对于镜面反射的效果体现不佳）</li>
<li>Phong Shading(像素点渲染)：对于每一个像素进行渲染，渲染依托的法线由顶点方程插值得到。（Phong Shading <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mpadded width="0px"><mo></mo></mpadded><mo>=</mo></mrow><annotation encoding="application/x-tex">\not =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span> Bling-Phong）</li>
</ol>
]]></content>
    </entry>
</feed>